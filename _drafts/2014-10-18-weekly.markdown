---
layout: post
title: "岂凡技术小报 第二期"
---

## @zxiy: Eclipse的工作空间目录中到底有啥？

因为试验了不少稀奇古怪的IDE，项目目录中充满了各种莫名其妙的文件。于是上周六走之前我把所有的项目文件都删了然后重新gclient了一份，用sbt编译通过就走人了。

这周一上来，我重新创建了Eclipse项目文件，然后导入工作空间，Eclipse就编译不通过了。

本来这是常见的事，然后我依次尝试了以前遇到这个情况之后成功解决的方法：

* 刷新&clean

* 重启Eclipse

* 关闭项目重新打开

* Eclipse中删除项目重新载入

* 取消所有项目依赖关系再重新勾上

* 关掉Eclipse，sbt重新编译再打开

* @Atry 提供的方法，Remove scala nature然后再加回来以及修改编译选项再改回去

然后都失败了。

最后我打开了老的demo项目`qforce-server-demo-1`的工作空间（工作空间目录和项目目录不在同一个目录），从eclipse移除所有项目，再载入手游服务器的项目文件，就好了。

这样看，Eclipse的工作空间中肯定包含了某些关于编译或者其他的设置，影响了我们是否可以成功编译。等有时间研究下到底是什么东西造成了这样的结果。

Update 10.16： 昨天研究了一下，怀疑是编译顺序导致的问题，但是上次的问题无法重现了，只能凭靠猜测了。这个选项在Eclipse的Window -> Preferences -> General -> Workspace -> Build Order里面设置。默认的选项似乎是项目名字典序，但是会用某种方法来解决其依赖关系。

我将entity从Build Order中移除，编译过程中一度出现了和之前一样的错误信息，但这些错误信息在最后还是被清除掉了（貌似通过依赖关系找到了被依赖项目？）建议下次再碰到这个问题的同学试下修改Build Order能否解决这个问题。

## @Atry: 管道

Stateless Future现在可以支持管道了： https://github.com/qifun/stateless-future-util/blob/master/src/main/scala/com/qifun/statelessFuture/util/Pipe.scala

 * 线程安全
 * 基于Lock-free算法
 * 可以用来实现复杂的状态机

@chank 上周说定时器逻辑太难写，现在用管道做个状态机就行了。

实现管道时，我发现Future宏的尾调用优化做得还不够好，于是重构了Future宏，现在尾调用优化很完美了： https://github.com/qifun/stateless-future/commit/9527b52fba29249561fb3625e3e36d0ddb860c91

## @Atry: 吃屎

看起来Typesafe公司没人懂得“删删删”的设计真谛。不过，就算是吃屎，到底该红烧大便还是要凉拌大便，他们仍然可以讨论得津津有味：https://github.com/scala/scala/pull/4042 （PS: 他们应该没人认识中文吧）。

有趣的是，Haxe的作者@ncannasse 却是个暴君。别人辛辛苦苦写好了补丁，@ncannasse 却总是以增加语言复杂度为理由拒绝。这大概也是Haxe能保持代码量比Scala小得多的原因吧。

## @chank: linux 内存使用率

使用top命令查看linux内存使用率的时候发现used的内存很多，free的内存很少，而看应用程序%MEM的内存使用率却很少

原来其实是linux的内存使用策略跟windows的不同

linux 会尽可能多地利用内存来提高系统的性能，因此linux会把很大一部分内存用作文件缓存

只有在应用程序需要内存的时候才会从cached缓存中分配内存给应用程序

在top命令中看到的cached Mem就是文件元数据和文件缓存，而buffers则主要是目录元数据缓存

因此应用程序总共使用的内存应该是：total-free-cached-buffers

## @chank: 项目依赖provided

把项目之间的依赖关系标为"provided"意味着在编译期才需要被依赖的项目，发布后就不再包含被依赖的项目了

例如json-stream-bson对json-stream的provided依赖表示在编译json-stream-bson时使用了json-stream，但发布之后就没有包含json-stream的代码了，在.sbt文件中的设置如下

  库依赖:
  
    libraryDependencies += "com.qifun" %% "json-stream" % "0.2.0-SNAPSHOT" % "provided"
    
  对应的项目间依赖:
  
    lazy val `json-stream-bson` = project dependsOn (`json-stream` % "provided")
    
通过这样设置项目之间的依赖关系就不需要在打包paraiso项目时使用sbt-assembly的first合并策略了。

ps: sbt-assembly的first在合并相同文件时是跟声明顺序有关的，使用的是第一个被声明依赖项目的文件
